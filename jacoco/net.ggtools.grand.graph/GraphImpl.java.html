<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GraphImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Grand: Graphical Representation of ANt Dependencies</a> &gt; <a href="index.source.html" class="el_package">net.ggtools.grand.graph</a> &gt; <span class="el_source">GraphImpl.java</span></div><h1>GraphImpl.java</h1><pre class="source lang-java linenums">// $Id$
/*
 * ====================================================================
 * Copyright (c) 2002-2003, Christophe Labouisse All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

package net.ggtools.grand.graph;

import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;

import net.ggtools.grand.exceptions.DuplicateElementException;
import net.ggtools.grand.log.LoggerManager;

import org.apache.commons.logging.Log;

/**
 * Simple GraphImpl implementation.
 *
 * @author Christophe Labouisse
 */
public class GraphImpl implements Graph {
    /**
     * An proxified iterator used for getNodes. This class ensure that on
     * deletion the node's links are also removed.
     *
     * @author Christophe Labouisse
     */
    private class NodeIterator implements Iterator&lt;Node&gt; {

        /**
         * Field lastNode.
         */
        private Node lastNode;

        /**
         * Field underlying.
         */
        private final Iterator&lt;Node&gt; underlying;

        /**
         * @param iterator
         *            underlying iterator.
         */
<span class="fc" id="L68">        private NodeIterator(final Iterator&lt;Node&gt; iterator) {</span>
<span class="fc" id="L69">            underlying = iterator;</span>
<span class="fc" id="L70">        }</span>

        /**
         * @return true if the iterator still has elements
         * @see java.util.Iterator#hasNext()
         */
        public boolean hasNext() {
<span class="fc" id="L77">            return underlying.hasNext();</span>
        }

        /**
         * @return the next element.
         * @see java.util.Iterator#next()
         */
        public Node next() {
<span class="fc" id="L85">            lastNode = underlying.next();</span>
<span class="fc" id="L86">            return lastNode;</span>
        }

        /**
         *
         * @see java.util.Iterator#remove()
         */
        public void remove() {
<span class="fc" id="L94">            underlying.remove();</span>
            // lastNode should not be null here since remove succeed.
<span class="fc" id="L96">            unlinkNode(lastNode);</span>
<span class="fc" id="L97">        }</span>
    }

    /**
     * Field log.
     */
<span class="fc" id="L103">    private static final Log LOG = LoggerManager.getLog(GraphImpl.class);</span>

    /**
     * Field elementFactory.
     */
    private GraphElementFactory elementFactory;

    /**
     * Field graphStartNode.
     */
    private Node graphStartNode;

    /**
     * The node storage for the main (sub)graph.
     */
    private final SubGraph mainSubGraph;

    /**
     * Field name.
     */
    private final String name;

    /**
     * Field subGraphList.
     */
<span class="fc" id="L128">    private final Map&lt;String, SubGraph&gt; subGraphList =</span>
            new LinkedHashMap&lt;String, SubGraph&gt;();

    /**
     * Creates a new named graph.
     *
     * @param graphName
     *            name for the new graph.
     */
<span class="fc" id="L137">    public GraphImpl(final String graphName) {</span>
<span class="fc" id="L138">        name = graphName;</span>
<span class="fc" id="L139">        mainSubGraph = new SubGraphImpl(graphName, new SubGraphImpl.NodeIteratorFactory() {</span>
            public final Iterator&lt;Node&gt; createNodeIterator(final Iterator&lt;Node&gt; iterator) {
<span class="fc" id="L141">                return new NodeIterator(iterator);</span>
            }
        });
<span class="fc" id="L144">    }</span>

    /**
     * Creates a new link between two nodes. Unlike {@link #createNode(String)},
     * this method do not require the link's name to be unique or not null. Both
     * nodes should be not null.
     *
     * @param linkName
     *            the new link name, can be &lt;code&gt;null&lt;/code&gt;
     * @param startNode
     *            start node
     * @param endNode
     *            end node
     * @return new link
     * @see net.ggtools.grand.graph.Graph#createLink(String, Node, Node)
     */
    public final Link createLink(final String linkName, final Node startNode,
            final Node endNode) {
<span class="fc" id="L162">        final Link link = getFactory().createLink(linkName, startNode, endNode);</span>
<span class="fc" id="L163">        startNode.addLink(link);</span>
<span class="fc" id="L164">        endNode.addBackLink(link);</span>
<span class="fc" id="L165">        return link;</span>
    }

    /**
     * Creates a new Node. The object's name must not be &lt;code&gt;null&lt;/code&gt; and
     * must be unique within the graph.
     *
     * @param nodeName
     *            new node's name
     * @return a new Node.
     * @throws DuplicateElementException
     *             if there is already a node with the same name.
     * @see net.ggtools.grand.graph.Graph#createNode(String)
     */
    public final Node createNode(final String nodeName)
            throws DuplicateElementException {
<span class="fc" id="L181">        return createNode(mainSubGraph, nodeName);</span>
    }

    /**
     * Method createNode.
     * @param subGraph SubGraph
     * @param nodeName String
     * @return Node
     * @throws DuplicateElementException
     *             if there is already a node with the same name.
     * @see net.ggtools.grand.graph.Graph#createNode(net.ggtools.grand.graph.SubGraph,
     *      java.lang.String)
     */
    public final Node createNode(final SubGraph subGraph, final String nodeName)
            throws DuplicateElementException {
        // We don't want to create a node if it's not gonna be inserted.
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">        if (subGraph.hasNode(nodeName)) {</span>
<span class="nc" id="L198">            throw new DuplicateElementException(&quot;Creating two nodes named &quot; + nodeName);</span>
        }
<span class="fc" id="L200">        final Node node = getFactory().createNode(nodeName);</span>
<span class="fc" id="L201">        subGraph.addNode(node);</span>
<span class="fc" id="L202">        return node;</span>
    }

    /**
     * Method createSubGraph.
     * @param subGraphName String
     * @return SubGraph
     * @throws DuplicateElementException
     *             if there is already a subgraph with the same name.
     * @see net.ggtools.grand.graph.Graph#createSubGraph(java.lang.String)
     */
    public final SubGraph createSubGraph(final String subGraphName)
            throws DuplicateElementException {
<span class="nc bnc" id="L215" title="All 2 branches missed.">        if (subGraphList.containsKey(subGraphName)) {</span>
<span class="nc" id="L216">            LOG.error(&quot;createSubGraph(subGraphName = &quot; + subGraphName</span>
                    + &quot;) - Cannot create two subgraphs with the same name&quot;, null);
<span class="nc" id="L218">            throw new DuplicateElementException(&quot;A subgraph called &quot;</span>
                    + subGraphName + &quot; already exists&quot;);
        }
<span class="nc" id="L221">        final SubGraph newSubGraph = new SubGraphImpl(subGraphName);</span>
<span class="nc" id="L222">        subGraphList.put(subGraphName, newSubGraph);</span>
<span class="nc" id="L223">        return newSubGraph;</span>
    }

    /**
     * Returns the graph's name.
     *
     * @return graph's name.
     * @see net.ggtools.grand.graph.Graph#getName()
     */
    public final String getName() {
<span class="fc" id="L233">        return name;</span>
    }

    /**
     * Method getNode.
     * @param nodeName String
     * @return Node
     * @see net.ggtools.grand.graph.NodeContainer#getNode(java.lang.String)
     */
    public final Node getNode(final String nodeName) {
<span class="fc" id="L243">        return mainSubGraph.getNode(nodeName);</span>
    }

    /**
     * Method getNodes.
     * @return Iterator&amp;lt;Node&amp;gt;
     * @see net.ggtools.grand.graph.NodeContainer#getNodes()
     */
    public final Iterator&lt;Node&gt; getNodes() {
<span class="fc" id="L252">        return mainSubGraph.getNodes();</span>
    }

    /**
     * Returns the start node of the graph. If no such node is defined,
     * &lt;code&gt;null&lt;/code&gt; will be returned.
     *
     * @return start node
     * @see net.ggtools.grand.graph.Graph#getStartNode()
     */
    public final Node getStartNode() {
<span class="fc" id="L263">        return graphStartNode;</span>
    }

    /**
     * Method getSubGraph.
     * @param subGraphName String
     * @return SubGraph
     * @see net.ggtools.grand.graph.Graph#getSubGraph(java.lang.String)
     */
    public final SubGraph getSubGraph(final String subGraphName) {
<span class="nc" id="L273">        return subGraphList.get(subGraphName);</span>
    }

    /**
     * Method getSubgraphs.
     * @return Iterator&amp;lt;SubGraph&amp;gt;
     * @see net.ggtools.grand.graph.Graph#getSubgraphs()
     */
    public final Iterator&lt;SubGraph&gt; getSubgraphs() {
<span class="nc" id="L282">        return subGraphList.values().iterator();</span>
    }

    /**
     * Method hasNode.
     * @param nodeName String
     * @return boolean
     * @see net.ggtools.grand.graph.NodeContainer#hasNode(java.lang.String)
     */
    public final boolean hasNode(final String nodeName) {
<span class="nc" id="L292">        return mainSubGraph.hasNode(nodeName);</span>
    }

    /**
     * Method hasSubGraph.
     * @param subGraphName String
     * @return boolean
     * @see net.ggtools.grand.graph.Graph#hasSubGraph(java.lang.String)
     */
    public final boolean hasSubGraph(final String subGraphName) {
<span class="nc" id="L302">        return subGraphList.containsKey(subGraphName);</span>
    }

    /**
     * Sets the graph starting node.
     *
     * @param node
     *            to be marked as the starting node of the graph.
     * @see net.ggtools.grand.graph.Graph#setStartNode(Node)
     */
    public final void setStartNode(final Node node) {
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">        if (graphStartNode != null) {</span>
<span class="nc" id="L314">            graphStartNode.clearAttributes(Node.ATTR_START_NODE);</span>
        }
<span class="fc" id="L316">        graphStartNode = node;</span>
<span class="pc bpc" id="L317" title="1 of 2 branches missed.">        if (graphStartNode != null) {</span>
<span class="fc" id="L318">            graphStartNode.setAttributes(Node.ATTR_START_NODE);</span>
        }
<span class="fc" id="L320">    }</span>

    /**
     * Returns the current element factory creating one if none exists yet. This
     * method can be overridden to use a custom factory.
     *
     * @return the element factory.
     */
    protected GraphElementFactory getFactory() {
<span class="nc bnc" id="L329" title="All 2 branches missed.">        if (elementFactory == null) {</span>
<span class="nc" id="L330">            elementFactory = new SimpleGraphElementFactory(this);</span>
        }
<span class="nc" id="L332">        return elementFactory;</span>
    }

    /**
     * Remove all links starting from or ending to the node. This method do not
     * remove the node from nodeList.
     *
     * @param node
     *            node to remove from the links.
     */
    protected final void unlinkNode(final Node node) {
<span class="pc bpc" id="L343" title="1 of 2 branches missed.">        if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L344">            LOG.trace(&quot;Unlinking node &quot; + node);</span>
        }

<span class="fc bfc" id="L347" title="All 2 branches covered.">        for (final Iterator&lt;Link&gt; iter = node.getLinks().iterator(); iter.hasNext();) {</span>
<span class="fc" id="L348">            final Link link = iter.next();</span>
<span class="fc" id="L349">            iter.remove();</span>
<span class="fc" id="L350">            final Node endNode = link.getEndNode();</span>
<span class="fc" id="L351">            endNode.removeBackLink(link);</span>
<span class="fc" id="L352">        }</span>

<span class="fc bfc" id="L354" title="All 2 branches covered.">        for (final Iterator&lt;Link&gt; iter = node.getBackLinks().iterator(); iter.hasNext();) {</span>
<span class="fc" id="L355">            final Link link = iter.next();</span>
<span class="fc" id="L356">            iter.remove();</span>
<span class="fc" id="L357">            final Node startNode = link.getStartNode();</span>
<span class="fc" id="L358">            startNode.removeLink(link);</span>
<span class="fc" id="L359">        }</span>

<span class="fc bfc" id="L361" title="All 2 branches covered.">        if (node == graphStartNode) {</span>
<span class="fc" id="L362">            graphStartNode = null;</span>
        }
<span class="fc" id="L364">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>